# CGI Initializers

Cole√ß√£o de pacotes Go para inicializa√ß√£o e configura√ß√£o de componentes essenciais em aplica√ß√µes web e APIs. Este projeto fornece uma suite completa de ferramentas para acelerar o desenvolvimento de aplica√ß√µes robustas e escal√°veis.

## üì¶ Pacotes Dispon√≠veis

### üîê [Auth](./auth/README.md)
Sistema de autentica√ß√£o e autoriza√ß√£o com suporte a JWT, middleware para frameworks web e valida√ß√£o de tokens.

**Principais funcionalidades:**
- Gera√ß√£o e valida√ß√£o de tokens JWT
- Middleware para Gin e Echo
- Autentica√ß√£o baseada em claims
- Refresh tokens
- Blacklist de tokens

### üîí [Crypt](./crypt/README.md)
Servi√ßos de criptografia para prote√ß√£o de dados sens√≠veis, incluindo hash de senhas e criptografia sim√©trica.

**Principais funcionalidades:**
- Hash seguro de senhas (bcrypt)
- Criptografia AES
- Gera√ß√£o de chaves seguras
- Middleware de criptografia
- Valida√ß√£o de integridade

### üìã [Formatter](./formatter/README.md)
Padroniza√ß√£o de respostas de erro e formata√ß√£o de dados para APIs REST.

**Principais funcionalidades:**
- Estruturas padronizadas de erro
- Formata√ß√£o JSON consistente
- Integra√ß√£o com frameworks web
- Logging estruturado
- Internacionaliza√ß√£o de mensagens

### ‚òÅÔ∏è [GCS](./gcs/README.md)
Inicializa√ß√£o simplificada do cliente Google Cloud Storage para opera√ß√µes com buckets e objetos.

**Principais funcionalidades:**
- Configura√ß√£o autom√°tica do cliente GCS
- Autentica√ß√£o via Service Account
- Gerenciamento de contexto
- Exemplos pr√°ticos de uso

### üìä [OpenTelemetry](./opentelemetry/README.md)
Observabilidade completa com tracing, m√©tricas e logging estruturado.

**Principais funcionalidades:**
- Configura√ß√£o autom√°tica de tracing
- M√©tricas customizadas
- Logging estruturado
- Propaga√ß√£o de contexto
- Integra√ß√£o com Jaeger/OTLP

### üåä [Pacific](./pacific/README.md)
Estrutura de dados e utilit√°rios para integra√ß√£o com APIs espec√≠ficas do dom√≠nio.

**Principais funcionalidades:**
- Estruturas de dados padronizadas
- Valida√ß√£o de entrada
- Tratamento de erros
- Serializa√ß√£o JSON
- Cliente HTTP integrado

### üóÑÔ∏è [Postgres](./postgres/README.md)
Gerenciamento de conex√µes e opera√ß√µes com banco de dados PostgreSQL.

**Principais funcionalidades:**
- Pool de conex√µes otimizado
- Opera√ß√µes CRUD simplificadas
- Suporte a transa√ß√µes
- Sistema de migra√ß√µes
- Monitoramento e m√©tricas

### ‚úÖ [Validator](./validator/README.md)
Valida√ß√£o robusta de dados com suporte a regras customizadas e internacionaliza√ß√£o.

**Principais funcionalidades:**
- Valida√ß√µes pr√©-definidas
- Regras customizadas
- Mensagens internacionalizadas
- Integra√ß√£o com frameworks web
- Cache de valida√ß√µes

## üöÄ In√≠cio R√°pido

### Instala√ß√£o

Cada pacote pode ser instalado individualmente:

```bash
# Instalar pacote espec√≠fico
go get github.com/seu-usuario/cgi/initializers/auth
go get github.com/seu-usuario/cgi/initializers/postgres
go get github.com/seu-usuario/cgi/initializers/formatter
# ... outros pacotes
```

### Exemplo de Uso Integrado

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    
    "github.com/gin-gonic/gin"
    "github.com/seu-usuario/cgi/initializers/auth"
    "github.com/seu-usuario/cgi/initializers/postgres"
    "github.com/seu-usuario/cgi/initializers/formatter"
    "github.com/seu-usuario/cgi/initializers/validator"
    "github.com/seu-usuario/cgi/initializers/opentelemetry"
)

func main() {
    ctx := context.Background()
    
    // Inicializar OpenTelemetry para observabilidade
    otelConfig := opentelemetry.Initialize(ctx, opentelemetry.Config{
        ServiceName:    "minha-api",
        ServiceVersion: "1.0.0",
        Environment:    "production",
    })
    defer otelConfig.Shutdown(ctx)
    
    // Inicializar banco de dados
    dbConfig := postgres.Config{
        Host:     os.Getenv("DB_HOST"),
        Port:     os.Getenv("DB_PORT"),
        User:     os.Getenv("DB_USER"),
        Password: os.Getenv("DB_PASSWORD"),
        Database: os.Getenv("DB_NAME"),
    }
    
    db, err := postgres.Initialize(dbConfig)
    if err != nil {
        log.Fatal("Erro ao conectar com banco:", err)
    }
    defer db.Close()
    
    // Inicializar autentica√ß√£o
    authConfig := auth.Config{
        SecretKey:       os.Getenv("JWT_SECRET"),
        TokenExpiration: "24h",
        Issuer:          "minha-api",
    }
    
    authService, err := auth.Initialize(authConfig)
    if err != nil {
        log.Fatal("Erro ao inicializar auth:", err)
    }
    
    // Inicializar validador
    validatorConfig := validator.Initialize(validator.Config{
        Language: "pt-BR",
    })
    
    // Configurar Gin
    r := gin.Default()
    
    // Middleware de observabilidade
    r.Use(opentelemetry.GinMiddleware())
    
    // Middleware de autentica√ß√£o
    r.Use(auth.GinMiddleware(authService))
    
    // Rotas da API
    api := r.Group("/api/v1")
    {
        api.POST("/login", loginHandler(authService))
        api.GET("/users", getUsersHandler(db))
        api.POST("/users", createUserHandler(db, validatorConfig))
    }
    
    // Iniciar servidor
    log.Println("Servidor iniciado na porta 8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}

func loginHandler(authService *auth.AuthService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var loginData struct {
            Email    string `json:"email" validate:"required,email"`
            Password string `json:"password" validate:"required,min=6"`
        }
        
        if err := c.ShouldBindJSON(&loginData); err != nil {
            c.JSON(400, formatter.ErrorResponse{
                Error: formatter.FormattedError{
                    Code:    "INVALID_INPUT",
                    Message: "Dados de entrada inv√°lidos",
                    Details: err.Error(),
                },
            })
            return
        }
        
        // L√≥gica de autentica√ß√£o...
        token, err := authService.GenerateToken("user123", map[string]interface{}{
            "email": loginData.Email,
        })
        
        if err != nil {
            c.JSON(500, formatter.ErrorResponse{
                Error: formatter.FormattedError{
                    Code:    "AUTH_ERROR",
                    Message: "Erro na autentica√ß√£o",
                },
            })
            return
        }
        
        c.JSON(200, gin.H{
            "token": token,
            "user": gin.H{
                "email": loginData.Email,
            },
        })
    }
}

func getUsersHandler(db *postgres.Database) gin.HandlerFunc {
    return func(c *gin.Context) {
        // L√≥gica para buscar usu√°rios...
        users := []map[string]interface{}{
            {"id": 1, "name": "Jo√£o", "email": "joao@email.com"},
            {"id": 2, "name": "Maria", "email": "maria@email.com"},
        }
        
        c.JSON(200, gin.H{
            "users": users,
            "total": len(users),
        })
    }
}

func createUserHandler(db *postgres.Database, validator *validator.ValidatorConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        var userData struct {
            Name     string `json:"name" validate:"required,min=2"`
            Email    string `json:"email" validate:"required,email"`
            Password string `json:"password" validate:"required,min=8"`
        }
        
        if err := c.ShouldBindJSON(&userData); err != nil {
            c.JSON(400, formatter.ErrorResponse{
                Error: formatter.FormattedError{
                    Code:    "INVALID_INPUT",
                    Message: "Dados de entrada inv√°lidos",
                },
            })
            return
        }
        
        // Validar dados
        if err := validator.ValidateStruct(userData); err != nil {
            c.JSON(400, formatter.ErrorResponse{
                Error: formatter.FormattedError{
                    Code:    "VALIDATION_ERROR",
                    Message: "Erro de valida√ß√£o",
                    Details: err.Error(),
                },
            })
            return
        }
        
        // L√≥gica para criar usu√°rio...
        c.JSON(201, gin.H{
            "message": "Usu√°rio criado com sucesso",
            "user": gin.H{
                "name":  userData.Name,
                "email": userData.Email,
            },
        })
    }
}
```

## üèóÔ∏è Arquitetura

### Princ√≠pios de Design

1. **Modularidade**: Cada pacote √© independente e pode ser usado isoladamente
2. **Configurabilidade**: Todas as configura√ß√µes s√£o externaliz√°veis
3. **Observabilidade**: Logging e tracing integrados em todos os componentes
4. **Seguran√ßa**: Pr√°ticas de seguran√ßa implementadas por padr√£o
5. **Performance**: Otimiza√ß√µes para alta performance e baixa lat√™ncia

### Padr√µes Utilizados

- **Dependency Injection**: Configura√ß√£o atrav√©s de structs de configura√ß√£o
- **Middleware Pattern**: Integra√ß√£o transparente com frameworks web
- **Factory Pattern**: Fun√ß√µes `Initialize()` para cria√ß√£o de inst√¢ncias
- **Observer Pattern**: Hooks para logging e monitoramento
- **Strategy Pattern**: Diferentes implementa√ß√µes para diferentes cen√°rios

## üîß Configura√ß√£o

### Vari√°veis de Ambiente

Crie um arquivo `.env` na raiz do seu projeto:

```bash
# Banco de Dados
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=senha123
DB_NAME=minha_aplicacao
DB_SSL_MODE=disable
DB_MAX_CONNECTIONS=25
DB_MAX_IDLE_CONNECTIONS=5

# Autentica√ß√£o
JWT_SECRET=sua-chave-secreta-muito-segura
JWT_EXPIRATION=24h
JWT_ISSUER=minha-api

# Google Cloud Storage
GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
GCS_BUCKET_NAME=meu-bucket

# OpenTelemetry
OTEL_SERVICE_NAME=minha-api
OTEL_SERVICE_VERSION=1.0.0
OTEL_ENVIRONMENT=production
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# Criptografia
ENCRYPTION_KEY=chave-de-32-caracteres-exatamente

# Valida√ß√£o
VALIDATOR_LANGUAGE=pt-BR
VALIDATOR_CACHE_SIZE=1000
```

### Arquivo de Configura√ß√£o YAML

```yaml
# config/app.yaml
app:
  name: "Minha API"
  version: "1.0.0"
  environment: "production"
  port: 8080

database:
  host: "localhost"
  port: 5432
  user: "postgres"
  password: "senha123"
  database: "minha_aplicacao"
  ssl_mode: "disable"
  max_connections: 25
  max_idle_connections: 5
  connection_timeout: "30s"

auth:
  secret_key: "sua-chave-secreta"
  token_expiration: "24h"
  refresh_expiration: "168h"
  issuer: "minha-api"
  algorithm: "HS256"

gcs:
  credentials_path: "/path/to/service-account.json"
  bucket_name: "meu-bucket"
  timeout: "30s"

opentelemetry:
  service_name: "minha-api"
  service_version: "1.0.0"
  environment: "production"
  exporter:
    type: "otlp"
    endpoint: "http://localhost:4317"
  sampling:
    ratio: 0.1

validator:
  language: "pt-BR"
  cache_size: 1000
  custom_messages:
    required: "Este campo √© obrigat√≥rio"
    email: "Formato de email inv√°lido"

logging:
  level: "info"
  format: "json"
  output: "stdout"
```

## üê≥ Docker

### Dockerfile

```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Instalar depend√™ncias do sistema
RUN apk add --no-cache git ca-certificates tzdata

# Copiar arquivos de depend√™ncias
COPY go.mod go.sum ./
RUN go mod download

# Copiar c√≥digo fonte
COPY . .

# Compilar aplica√ß√£o
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Runtime stage
FROM alpine:latest

WORKDIR /root/

# Instalar certificados CA
RUN apk --no-cache add ca-certificates tzdata

# Copiar bin√°rio
COPY --from=builder /app/main .

# Copiar arquivos de configura√ß√£o
COPY --from=builder /app/config ./config

# Expor porta
EXPOSE 8080

# Comando de execu√ß√£o
CMD ["./main"]
```

### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=postgres
      - DB_PASSWORD=senha123
      - DB_NAME=minha_aplicacao
      - JWT_SECRET=sua-chave-secreta
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger:4317
    depends_on:
      - postgres
      - redis
      - jaeger
    volumes:
      - ./config:/root/config
      - ./credentials:/root/credentials

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=senha123
      - POSTGRES_DB=minha_aplicacao
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "4317:4317"
      - "4318:4318"
    environment:
      - COLLECTOR_OTLP_ENABLED=true

volumes:
  postgres_data:
  redis_data:
```

## üß™ Testes

### Estrutura de Testes

```bash
# Executar todos os testes
go test ./...

# Executar testes com coverage
go test -cover ./...

# Executar testes de integra√ß√£o
go test -tags=integration ./...

# Executar benchmarks
go test -bench=. ./...
```

### Exemplo de Teste de Integra√ß√£o

```go
// tests/integration_test.go
//go:build integration

package tests

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/seu-usuario/cgi/initializers/postgres"
    "github.com/seu-usuario/cgi/initializers/auth"
)

func TestFullIntegration(t *testing.T) {
    ctx := context.Background()
    
    // Setup banco de dados de teste
    dbConfig := postgres.Config{
        Host:     "localhost",
        Port:     "5432",
        User:     "postgres",
        Password: "senha123",
        Database: "test_db",
    }
    
    db, err := postgres.Initialize(dbConfig)
    assert.NoError(t, err)
    defer db.Close()
    
    // Setup autentica√ß√£o
    authConfig := auth.Config{
        SecretKey:       "test-secret-key",
        TokenExpiration: "1h",
        Issuer:          "test-api",
    }
    
    authService, err := auth.Initialize(authConfig)
    assert.NoError(t, err)
    
    // Teste de gera√ß√£o de token
    token, err := authService.GenerateToken("user123", map[string]interface{}{
        "email": "test@example.com",
    })
    assert.NoError(t, err)
    assert.NotEmpty(t, token)
    
    // Teste de valida√ß√£o de token
    claims, err := authService.ValidateToken(token)
    assert.NoError(t, err)
    assert.Equal(t, "user123", claims.Subject)
}
```

## üìä Monitoramento

### M√©tricas Dispon√≠veis

- **Database**: Conex√µes ativas, tempo de resposta, queries por segundo
- **Auth**: Tokens gerados, valida√ß√µes, falhas de autentica√ß√£o
- **HTTP**: Requests por segundo, lat√™ncia, c√≥digos de status
- **GCS**: Uploads, downloads, erros de opera√ß√£o
- **Validator**: Valida√ß√µes executadas, cache hits/misses

### Dashboards Grafana

Exemplos de queries Prometheus:

```promql
# Taxa de requests HTTP
rate(http_requests_total[5m])

# Lat√™ncia P95 de requests
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

# Conex√µes ativas do banco
postgres_connections_active

# Taxa de erro de autentica√ß√£o
rate(auth_validation_errors_total[5m])
```

## üîí Seguran√ßa

### Checklist de Seguran√ßa

- [ ] Credenciais em vari√°veis de ambiente
- [ ] Tokens JWT com expira√ß√£o adequada
- [ ] Senhas hasheadas com bcrypt
- [ ] Conex√µes de banco com SSL
- [ ] Rate limiting implementado
- [ ] Logs sem informa√ß√µes sens√≠veis
- [ ] Valida√ß√£o de entrada rigorosa
- [ ] CORS configurado adequadamente

### Auditoria de Seguran√ßa

```bash
# Verificar depend√™ncias vulner√°veis
go list -json -m all | nancy sleuth

# An√°lise est√°tica de seguran√ßa
gosec ./...

# Verificar licen√ßas
go-licenses check ./...
```

## üöÄ Deploy

### Kubernetes

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: minha-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: minha-api
  template:
    metadata:
      labels:
        app: minha-api
    spec:
      containers:
      - name: api
        image: minha-api:latest
        ports:
        - containerPort: 8080
        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: host
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-secret
              key: jwt-secret
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## üìö Documenta√ß√£o

Cada pacote possui documenta√ß√£o detalhada:

- [Auth](./auth/README.md) - Sistema de autentica√ß√£o
- [Crypt](./crypt/README.md) - Servi√ßos de criptografia
- [Formatter](./formatter/README.md) - Formata√ß√£o de respostas
- [GCS](./gcs/README.md) - Google Cloud Storage
- [OpenTelemetry](./opentelemetry/README.md) - Observabilidade
- [Pacific](./pacific/README.md) - Estruturas de dados
- [Postgres](./postgres/README.md) - Banco de dados
- [Validator](./validator/README.md) - Valida√ß√£o de dados

## ü§ù Contribui√ß√£o

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/nova-feature`)
3. Commit suas mudan√ßas (`git commit -am 'Adiciona nova feature'`)
4. Push para a branch (`git push origin feature/nova-feature`)
5. Abra um Pull Request

### Padr√µes de C√≥digo

- Use `gofmt` para formata√ß√£o
- Execute `golint` para verificar estilo
- Mantenha cobertura de testes > 80%
- Documente fun√ß√µes p√∫blicas
- Siga os padr√µes de nomenclatura Go

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

## üÜò Suporte

- **Issues**: [GitHub Issues](https://github.com/seu-usuario/cgi/issues)
- **Discuss√µes**: [GitHub Discussions](https://github.com/seu-usuario/cgi/discussions)
- **Email**: suporte@exemplo.com

---

**Desenvolvido com ‚ù§Ô∏è pela equipe CGI**